#define _GNU_SOURCE 500
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <getopt.h>
#include <string.h>

struct option options[] = {
    {
        name:    "help",
        has_arg: 0,
        flag:    NULL,
        val:     'h'
    },
    {
        name:    "depfile",
        has_arg: 1,
        flag:    NULL,
        val:     'd'
    }
};

static const char* warning_comment =
"/*\n"
" * AUTO-GENERATED CODE -- DO NOT EDIT\n"
" * This file is generated by glslc, and may be regenerated in the future.\n"
" * Please refrain from modifying or committing this file to source control.\n"
"*/\n";

ssize_t read_line(char** ptr, size_t* len, FILE* f) {
    return getline(ptr, len, f);
}

void print_info() {
    printf("Usage: glslc [OPTIONS] input\n\n");
    printf("Options:\n");
    printf("  -h, --help        Show this message\n");
    printf("  -o [filepath]     Print to filepath instead of stderr\n");
}

char* gen_define_name(const char* filename) {
    char* name = calloc(strlen(filename), sizeof(char));
    bool start_content = false;
    for(int i = 0; i < strlen(filename); ++i) {
        if(filename[i] >= 'A' && filename[i] <= 'Z') {
            name[i] = filename[i];
            start_content = true;
        } else if(filename[i] >= 'a' && filename[i] <= 'z') {
            name[i] = filename[i] - 32;
            start_content = true;
        } else if(filename[i] >= '0' && filename[i] <= '9' && start_content)
            name[i] = filename[i];
        else
            name[i] = '_';

    }

    return name;
}

char* gen_var_name(const char* filename) {
    char* name = calloc(strlen(filename), sizeof(char));
    bool start_content = false;
    for(int i = 0; i < strlen(filename); ++i) {
        if(filename[i] >= 'A' && filename[i] <= 'Z') {
            name[i] = filename[i] + 32;
            start_content = true;
        } else if(filename[i] >= 'a' && filename[i] <= 'z') {
            name[i] = filename[i];
            start_content = true;
        } else if(filename[i] >= '0' && filename[i] <= '9' && start_content)
            name[i] = filename[i];
        else
            name[i] = '_';

    }

    return name;
}

void extract_line(const char* line, ssize_t len, char** output) {
    bool skipping_ws = false;
    int i = 0;
    for(i = 0; i < len; ++i) {
        if(line[i] == ':' && !skipping_ws) {
            skipping_ws = true;
            continue;
        }

        if(skipping_ws && line[i] != ' ' && line[i] != '\t') {
            break;
        }
    }

    if(i == len) {
        fprintf(stderr, "Failed to parse shader definition file: Line \"%s\" is malformed", line);
        exit(1);
    }
    *output = calloc(len - i, sizeof(char));
    memcpy(*output, line + (i * sizeof(char)), (len - i - 1) * sizeof(char));
}

void make_path_relative(const char* base_path, char** rel_path) {
    char* pos = strrchr(base_path, '/');

    if(pos) {
        char* temp = *rel_path;
        *rel_path = calloc(strlen(*rel_path) + (pos - base_path) / sizeof(char) + 1, sizeof(char));
        memcpy(*rel_path, base_path, (pos - base_path) + sizeof(char));
        strcat(*rel_path, temp);

        free(temp);
    }
}

void parse_definitions(const char* filename, char** vs, char** fs, char** gs, char** ts, char** name, const char* deppath) {
    FILE* infile = fopen(filename, "r");
    if(!infile) {
        fprintf(stderr, "Error: Can't open shader definition file %s: %s\n", filename, strerror(errno));
        exit(1);
    }

    while(true) {
        char* line = NULL;
        size_t len = 0;
        ssize_t read = read_line(&line, &len, infile);

        if(read == -1 || read < 4) {
            free(line);
            fclose(infile);
            return;
        }

        if(!strncmp(line, "vert", 4)) {
            extract_line(line, read, vs);
            if(*vs != NULL && *vs[0] != '/')
                make_path_relative(filename, vs);
        } else if(!strncmp(line, "frag", 4)) {
            extract_line(line, read, fs);
            if(*fs != NULL && *fs[0] != '/')
                make_path_relative(filename, fs);
        } else if(!strncmp(line, "geom", 4)) {
            extract_line(line, read, gs);
            if(*gs != NULL && *gs[0] != '/')
                make_path_relative(filename, gs);
        } else if(!strncmp(line, "tess", 4)) {
            extract_line(line, read, gs);
            if(*ts != NULL && *ts[0] != '/')
                make_path_relative(filename, ts);
        } else if(!strncmp(line, "name", 4)) {
            extract_line(line, read, name);
        } else {
            fprintf(stderr, "Failed to parse shader definition file %s: Unkown option \"%.4s\"\n", filename, line);
            free(line);
            fclose(infile);
            exit(1);
        }

        free(line);
    }
}

void start_file(FILE* output, const char* filename) {
    char* defname = gen_define_name(filename);
    fprintf(output, "%s\n", warning_comment);
    fprintf(output, "#ifndef %s_GLSL\n#define %s_GLSL\n", defname, defname);
    free(defname);
}

void write_file(FILE* output, const char* infilename, const char* filename, const char* suffix) {
    FILE* infile = fopen(infilename, "r");
    if(!infile) {
        fprintf(stderr, "Error: Can't open file %s for reading: %s\n", infilename, strerror(errno));
        exit(1);
    }

    if(fseek(infile, 0L, SEEK_END) == -1) {
        fprintf(stderr, "Error reading %s: %s\n", filename, strerror(errno));
        exit(1);
    }
    long len = ftell(infile);
    rewind(infile);
    char* ptr = calloc(len, sizeof(char));
    fread(ptr, sizeof(char), len, infile);
    fclose(infile);

    char* varname = gen_var_name(filename);

    long trailing_cursor = 0;
    long linecount = 0;
    for(long i = 0; i < len; ++i) {
        if(ptr[i] == '\n') {
            if(i - trailing_cursor > 0) {
                linecount++;
            }
            trailing_cursor = i + 1;
        }
    }

    char** lines = calloc(linecount, sizeof(char*));
    long line_cursor = 0;
    trailing_cursor = 0;
    for(long i = 0; i < len; ++i) {
        if(ptr[i] == '\n') {
            if(i - trailing_cursor > 0) {
                lines[line_cursor] = calloc(i - trailing_cursor + 1, sizeof(char));
                memcpy(lines[line_cursor], ptr + (trailing_cursor * sizeof(char)), i - trailing_cursor);
                line_cursor++;
            }
            trailing_cursor = i + 1;
        }
    }

    fprintf(output, "const char* %s_%s_data[]=\n{\n", varname, suffix);
    for(long i = 0; i < linecount; ++i)
        fprintf(output, "    \"%s\\n\"\n", lines[i]);
    fprintf(output, "};\n");

    free(varname);
}

void end_file(FILE* output, const char* filename, bool has_vert, bool has_frag, bool has_geom, bool has_tess) {
    if(has_vert && has_frag)
    {
        if(has_geom)
            fprintf(output, "#define compile_shader_%s() shader_new_vgf(%s_vs_data, %s_gs_data, %s_fs_data)\n", filename, filename, filename, filename);
        else
            fprintf(output, "#define compile_shader_%s() shader_new_vf(%s_vs_data, %s_fs_data)\n", filename, filename, filename);
    }
    fprintf(output, "#endif\n");
}

int main(int argc, char* argv[]) {
    if(argc <= 1) {
        print_info();
        return 0;
    }

    const char* output = NULL;
    const char* deppath = NULL;

    int c;
    while((c = getopt_long(argc, argv, "hd:o:", options, NULL)) != -1) {
        switch(c) {
            case '?':
            case 'h':
                print_info();
                return 0;

            case 'd':
                deppath = optarg;
                fprintf(stderr, "d %s\n", deppath);
                break;

            case 'o':
                output = optarg;
                fprintf(stderr, "o %s\n", output);
                break;

            default:
                fprintf(stderr, "Failed to parse option 0%o\n", c);
        }
    }

    if(optind >= argc) {
        fprintf(stderr, "Error: No output file specified\n");
        print_info();
        return 1;
    }

    char* vsfile = NULL;
    char* fsfile = NULL;
    char* gsfile = NULL;
    char* tsfile = NULL;
    char* name   = NULL;
    parse_definitions(argv[optind], &vsfile, &fsfile, &gsfile, &tsfile, &name, deppath);

    FILE* outfile = output == NULL ? stdout : fopen(output, "w");
    if(!vsfile && !fsfile && !gsfile && !tsfile) {
        fprintf(stderr, "Error: Shader definition file contains no shaders\n");
    }

    FILE* depfile = deppath ? fopen(deppath, "w") : NULL;
    if(!depfile) {
        fprintf(stderr, "Error: Can't open shader dependency file %s: %s\n", deppath, strerror(errno));
        exit(1);
    }

    if(depfile)
        fprintf(depfile, "%s: ", output);

    const char* fn = name == NULL ? output == NULL ? argv[optind] : output : name;
    start_file(outfile, fn);
    if(vsfile)
    {
        write_file(outfile, vsfile, fn, "vs");
        fprintf(depfile, "%s ", vsfile);
    }
    if(fsfile)
    {
        write_file(outfile, fsfile, fn, "fs");
        fprintf(depfile, "%s ", fsfile);
    }
    if(gsfile)
    {
        write_file(outfile, gsfile, fn, "gs");
        fprintf(depfile, "%s ", gsfile);
    }
    if(tsfile)
    {
        write_file(outfile, tsfile, fn, "ts");
        fprintf(depfile, "%s ", tsfile);
    }
    end_file(outfile, fn, vsfile, fsfile, gsfile, tsfile);
    fclose(outfile);

    if(depfile)
        fclose(depfile);

    return 0;
}
